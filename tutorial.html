<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>SMS REST API tutorial &mdash; REST API SDK for SMS 1.0.0 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="REST API SDK for SMS 1.0.0 documentation" href="index.html" />
    <link rel="next" title="clx" href="modules.html" />
    <link rel="prev" title="Welcome to REST API SDK for SMS’s documentation!" href="index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="sms-rest-api-tutorial">
<h1>SMS REST API tutorial<a class="headerlink" href="#sms-rest-api-tutorial" title="Permalink to this headline">¶</a></h1>
<p>The purpose of this document is to present the basic concepts of the
CLX Communications HTTP REST Messaging API and how to use it from
Python using the HTTP REST Messaging API SDK.</p>
<div class="section" id="http-rest-messaging-api-basics">
<h2>HTTP REST Messaging API basics<a class="headerlink" href="#http-rest-messaging-api-basics" title="Permalink to this headline">¶</a></h2>
<p>HTTP REST Messaging API is a REST API that is provided by CLX
Communications for sending and receiving SMS messages. It also
provides various other services supporting this task such as managing
groups of recipients, tagging, and so forth.</p>
<p>Note, for brevity we will in this document refer to HTTP REST
Messaging API as <em>XMS API</em> and the HTTP REST Messaging API service or
HTTP endpoint as <em>XMS</em>.</p>
<p>A great benefit of the XMS API is that it allows you to easily create
and send <em>batch SMS messages</em>, that is, SMS messages that can have
multiple recipients. When creating a batch message it is possible to
use <em>message templates</em>, which allows each recipient to receive a
personalized message.</p>
<p>To use XMS it is necessary to have a <em>service plan identifier</em> and an
<em>authentication token</em>, which can be obtained by creating an XMS
service plan.</p>
<p>For full documentation of the XMS API please refer to the <a class="reference external" href="https://www.clxcommunications.com/docs/sms/http-rest.html">REST API
documentation site</a>. The documentation site contains up-to-date
information about, for example, status and error codes.</p>
</div>
<div class="section" id="interacting-with-xms-through-python">
<h2>Interacting with XMS through Python<a class="headerlink" href="#interacting-with-xms-through-python" title="Permalink to this headline">¶</a></h2>
<p>Using this Python SDK, all interaction with XMS happens through an
<em>XMS client</em>, which can be created using the service plan identifier
and authentication token. Further configuration can be performed on
the XMS client but in the typical case a service plan identifier and
authentication token is sufficient.</p>
<p>Once an XMS client has been created it is possible to send requests to
XMS and receive its responses. This is done by calling a suitable
method on the XMS client, supplying arguments as necessary, and
receiving the response as the return value.</p>
<p>This SDK has a focus on asynchronous operation and all interaction
with XMS happens asynchronously. Therefore, while synchronous methods
are supplied within the library their use is discouraged in most
practical applications.</p>
<p>The arguments passed to a connection method are sometimes very simple,
fetching a previously create batch simply requires the batch
identifier as argument. Other times the arguments are complicated, for
example to create the batch it may be necessary to supply a large
number of arguments that specify destination addresses, the message
body, expiry times, and so on. For such complex arguments we use
classes whose methods correspond to the different parameters that are
relevant for the request.</p>
<p>In general the terms used in XMS carry through to the Python API with
one major exception. The REST API uses the terms <em>to</em> and <em>from</em> to
indicate a message originator and message destination, respectively.
In the Python API these are instead denoted <em>recipient</em> and <em>sender</em>.
The cause of this name change is to have less confusing and more
idiomatic Python method and property names.</p>
</div>
<div class="section" id="connection-management">
<h2>Connection management<a class="headerlink" href="#connection-management" title="Permalink to this headline">¶</a></h2>
<p>The first step in using the XMS SDK is to create an XMS client object,
this object is instantiated from the <a class="reference internal" href="clx.xms.html#clx.xms.client.Client" title="clx.xms.client.Client"><code class="xref py py-class docutils literal"><span class="pre">Client</span></code></a> class and it
describes everything we need in order to talk with the XMS API
endpoint. The minimal amount of information needed are the service
plan identifier and the authentication token and, as previously
mentioned, these will be provided to you when creating an XMS service.</p>
<p>Assuming we have been given the service plan identifier &#8220;myplan&#8221; and
authentication token &#8220;mytoken&#8221; then an XMS client <code class="docutils literal"><span class="pre">client</span></code> can be
created as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">client</span> <span class="o">=</span> <span class="n">clx</span><span class="o">.</span><span class="n">xms</span><span class="o">.</span><span class="n">Client</span><span class="p">(</span><span class="s1">&#39;myserviceplan&#39;</span><span class="p">,</span> <span class="s1">&#39;mytoken&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Once created the client can be used to interact with XMS in the ways
described in the following sections of this tutorial.</p>
<p>By default the connection will use
<code class="docutils literal"><span class="pre">https://api.clxcommunications.com/xms</span></code> as XMS endpoint. This can be
overridden by providing an extra argument to the <a class="reference internal" href="clx.xms.html#clx.xms.client.Client" title="clx.xms.client.Client"><code class="xref py py-class docutils literal"><span class="pre">Client</span></code></a>
constructor. For example, the code:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">client</span> <span class="o">=</span> <span class="n">clx</span><span class="o">.</span><span class="n">xms</span><span class="o">.</span><span class="n">Client</span><span class="p">(</span>
    <span class="s1">&#39;myserviceplan&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mytoken&#39;</span><span class="p">,</span>
    <span class="s1">&#39;https://my.test.host:3000/my/base/path&#39;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>would make the client object believe that the <a class="reference external" href="https://www.clxcommunications.com/docs/sms/http-rest.html#batches-endpoint)">batches endpoint</a>
endpoint is
<code class="docutils literal"><span class="pre">https://my.test.host:3000/my/base/path/v1/myplan/batches</span></code>.</p>
</div>
<div class="section" id="sending-batches">
<h2>Sending batches<a class="headerlink" href="#sending-batches" title="Permalink to this headline">¶</a></h2>
<p>Creating a batch is typically one of the first things one would like
to do when starting to use XMS. To create a batch we must specify, at
a minimum, the originating address (typically a short code), one or
more recipient addresses (typically MSISDNs), and the message body.
Sending a simple hello world message to one recipient is then
accomplished using:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">batch_params</span> <span class="o">=</span> <span class="n">clx</span><span class="o">.</span><span class="n">xms</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">MtBatchTextSmsCreate</span><span class="p">()</span>
<span class="n">batch_params</span><span class="o">.</span><span class="n">sender</span> <span class="o">=</span> <span class="s1">&#39;12345&#39;</span>
<span class="n">batch_params</span><span class="o">.</span><span class="n">recipients</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;987654321&#39;</span><span class="p">}</span>
<span class="n">batch_params</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="s1">&#39;Hello, World!&#39;</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">create_batch</span><span class="p">(</span><span class="n">batch_params</span><span class="p">)</span>
</pre></div>
</div>
<p>You will notice a few things with this code. We are using a <code class="docutils literal"><span class="pre">client</span></code>
variable that corresponds to an XMS client that we assume has been
previously created. We are calling the
<a class="reference internal" href="clx.xms.html#clx.xms.client.Client.create_batch" title="clx.xms.client.Client.create_batch"><code class="xref py py-meth docutils literal"><span class="pre">create_batch()</span></code></a> method on the client
with a single argument that describes the batch we wish to create.</p>
<p>Describing the batch is done using an <a class="reference internal" href="clx.xms.html#clx.xms.api.MtBatchTextSmsCreate" title="clx.xms.api.MtBatchTextSmsCreate"><code class="xref py py-class docutils literal"><span class="pre">MtBatchTextSmsCreate</span></code></a>
object. For a batch with a binary body you would similarly describe it
using an <a class="reference internal" href="clx.xms.html#clx.xms.api.MtBatchBinarySmsCreate" title="clx.xms.api.MtBatchBinarySmsCreate"><code class="xref py py-class docutils literal"><span class="pre">MtBatchBinarySmsCreate</span></code></a> object.</p>
<p>The return value of a batch create call is a
<a class="reference internal" href="clx.xms.html#clx.xms.api.MtBatchTextSmsResult" title="clx.xms.api.MtBatchTextSmsResult"><code class="xref py py-class docutils literal"><span class="pre">MtBatchTextSmsResult</span></code></a> or <a class="reference internal" href="clx.xms.html#clx.xms.api.MtBatchBinarySmsResult" title="clx.xms.api.MtBatchBinarySmsResult"><code class="xref py py-class docutils literal"><span class="pre">MtBatchBinarySmsResult</span></code></a>
object that contains not only the submitted batch information but also
information included by XMS, such that the unique batch identifier,
the creation time, etc. For example, to simply print the batch
identifier we could add the code:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;Batch id is </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">result</span><span class="o">.</span><span class="n">batch_id</span><span class="p">)</span>
</pre></div>
</div>
<p>It is not much harder to create a more complicated batch, for example,
here we create a parameterized message with multiple recipients and a
scheduled send time:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">batch_params</span> <span class="o">=</span> <span class="n">clx</span><span class="o">.</span><span class="n">xms</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">MtBatchTextSmsCreate</span><span class="p">()</span>
<span class="n">batch_params</span><span class="o">.</span><span class="n">sender</span> <span class="o">=</span> <span class="s1">&#39;12345&#39;</span>
<span class="n">batch_params</span><span class="o">.</span><span class="n">recipients</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;987654321&#39;</span><span class="p">,</span> <span class="s1">&#39;123456789&#39;</span><span class="p">,</span> <span class="s1">&#39;567894321&#39;</span><span class="p">}</span>
<span class="n">batch_params</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="s1">&#39;Hello, ${name}!&#39;</span>
<span class="n">batch_params</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;987654321&#39;</span><span class="p">:</span> <span class="s1">&#39;Mary&#39;</span><span class="p">,</span>
    <span class="s1">&#39;123456789&#39;</span><span class="p">:</span> <span class="s1">&#39;Joe&#39;</span><span class="p">,</span>
    <span class="s1">&#39;default&#39;</span><span class="p">:</span> <span class="s1">&#39;valued customer&#39;</span>
<span class="p">}</span>
<span class="n">batch_params</span><span class="o">.</span><span class="n">send_at</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">UTC</span><span class="p">)</span>
<span class="n">batch</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">create_batch</span><span class="p">(</span><span class="n">batch_params</span><span class="p">)</span>
</pre></div>
</div>
<p>On the other hand, for the common case where we need to send a text or
binary message to a single recipient there are
<a class="reference internal" href="clx.xms.html#clx.xms.client.Client.create_text_message" title="clx.xms.client.Client.create_text_message"><code class="xref py py-meth docutils literal"><span class="pre">create_text_message()</span></code></a> and
<a class="reference internal" href="clx.xms.html#clx.xms.client.Client.create_binary_message" title="clx.xms.client.Client.create_binary_message"><code class="xref py py-meth docutils literal"><span class="pre">create_binary_message()</span></code></a> which do not
require an API object. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">client</span><span class="o">.</span><span class="n">create_text_message</span><span class="p">(</span>
    <span class="n">sender</span><span class="o">=</span><span class="s1">&#39;1234&#39;</span><span class="p">,</span>
    <span class="n">recipient</span><span class="o">=</span><span class="s1">&#39;987654321&#39;</span><span class="p">,</span>
    <span class="n">body</span><span class="o">=</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>and:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">client</span><span class="o">.</span><span class="n">create_binary_message</span><span class="p">(</span>
    <span class="n">sender</span><span class="o">=</span><span class="s1">&#39;1234&#39;</span><span class="p">,</span>
    <span class="n">recipient</span><span class="o">=</span><span class="s1">&#39;987654321&#39;</span><span class="p">,</span>
    <span class="n">udh</span><span class="o">=</span><span class="n">b</span><span class="s1">&#39;</span><span class="se">\xf0\x0f</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="n">body</span><span class="o">=</span><span class="n">b</span><span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Internally these create batches with a single recipient and they
return values of types <a class="reference internal" href="clx.xms.html#clx.xms.api.MtBatchTextSmsResult" title="clx.xms.api.MtBatchTextSmsResult"><code class="xref py py-class docutils literal"><span class="pre">MtBatchTextSmsResult</span></code></a> and
<a class="reference internal" href="clx.xms.html#clx.xms.api.MtBatchBinarySmsResult" title="clx.xms.api.MtBatchBinarySmsResult"><code class="xref py py-class docutils literal"><span class="pre">MtBatchBinarySmsResult</span></code></a>, respectively.</p>
</div>
<div class="section" id="fetching-batches">
<h2>Fetching batches<a class="headerlink" href="#fetching-batches" title="Permalink to this headline">¶</a></h2>
<p>If you have a batch identifier and would like to retrieve information
concerning that batch then it is sufficient to use the
<a class="reference internal" href="clx.xms.html#clx.xms.client.Client.fetch_batch" title="clx.xms.client.Client.fetch_batch"><code class="xref py py-meth docutils literal"><span class="pre">fetch_batch()</span></code></a> method. Thus, if the
desired batch identifier is available in the variable <code class="docutils literal"><span class="pre">batch_id</span></code>
then one could write:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>batch_id = # …
result = client.fetch_batch(batch_id)
print(&#39;Batch id is %s&#39; % result.batch_id)
</pre></div>
</div>
<p>Note, since <a class="reference internal" href="clx.xms.html#clx.xms.client.Client.fetch_batch" title="clx.xms.client.Client.fetch_batch"><code class="xref py py-meth docutils literal"><span class="pre">fetch_batch()</span></code></a> does not know
ahead of time whether the fetched batch is textual or binary it
returns a value of the type <a class="reference internal" href="clx.xms.html#clx.xms.api.MtBatchSmsResult" title="clx.xms.api.MtBatchSmsResult"><code class="xref py py-class docutils literal"><span class="pre">MtBatchSmsResult</span></code></a>.
This type is the base class of
<a class="reference internal" href="clx.xms.html#clx.xms.api.MtBatchTextSmsResult" title="clx.xms.api.MtBatchTextSmsResult"><code class="xref py py-class docutils literal"><span class="pre">MtBatchTextSmsResult</span></code></a> and
<a class="reference internal" href="clx.xms.html#clx.xms.api.MtBatchBinarySmsResult" title="clx.xms.api.MtBatchBinarySmsResult"><code class="xref py py-class docutils literal"><span class="pre">MtBatchBinarySmsResult</span></code></a> and you may need to use,
for example, <code class="docutils literal"><span class="pre">isinstance</span></code> to determine the actual type.</p>
</div>
<div class="section" id="listing-batches">
<h2>Listing batches<a class="headerlink" href="#listing-batches" title="Permalink to this headline">¶</a></h2>
<p>Once you have created a few batches it may be interesting to retrieve
a list of all your batches. Retrieving listings of batches is done
through a <em>paged result</em>. This means that a single request to XMS may
not retrieve all batches. As a result, when calling the
<a class="reference internal" href="clx.xms.html#clx.xms.client.Client.fetch_batches" title="clx.xms.client.Client.fetch_batches"><code class="xref py py-meth docutils literal"><span class="pre">fetch_batches()</span></code></a> method on your XMS client
it will not simply return a list of batches but rather a
<a class="reference internal" href="clx.xms.html#clx.xms.api.Pages" title="clx.xms.api.Pages"><code class="xref py py-class docutils literal"><span class="pre">clx.xms.api.Pages</span></code></a> object. The pages object in turn can be
used to fetch specific pages or iterate over all available pages while
transparently performing necessary page requests.</p>
<p>To limit the number of batches in the list it is also possible to
supply a filter that will restrict the fetched batches, for example to
those sent after a particular date or having a specific tag or sender.</p>
<p>More specifically, to print the identifier of each batch sent on
2016-12-01 and having the tag &#8220;signup_notification&#8221;, we may write
something like the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">pages</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">fetch_batches</span><span class="p">(</span>
    <span class="n">tag</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;signup_notification&#39;</span><span class="p">},</span>
    <span class="n">start_date</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">end_date</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>

<span class="k">for</span> <span class="n">page</span> <span class="ow">in</span> <span class="n">pages</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">page</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Batch ID: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">batch</span><span class="o">.</span><span class="n">batch_id</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="other-xms-requests">
<h2>Other XMS requests<a class="headerlink" href="#other-xms-requests" title="Permalink to this headline">¶</a></h2>
<p>We have only shown explicitly how to create, list and fetch batches
but the same principles apply to all other XMS calls within the SDK.
For example, to fetch a group one could use the previously given
instructions for fetching batches and simply use
<a class="reference internal" href="clx.xms.html#clx.xms.client.Client.fetch_group" title="clx.xms.client.Client.fetch_group"><code class="xref py py-meth docutils literal"><span class="pre">fetch_group()</span></code></a> with a group identifier.</p>
<p>Canceling a batch and deleting a group is the same as fetching with
the exception that they do not return any result.</p>
</div>
<div class="section" id="handling-errors">
<h2>Handling errors<a class="headerlink" href="#handling-errors" title="Permalink to this headline">¶</a></h2>
<p>Any error that occurs during an API operation will result in an
exception being thrown. The exceptions raised explicitly by the SDK
all inherit from the <a class="reference internal" href="clx.xms.html#clx.xms.exceptions.ApiException" title="clx.xms.exceptions.ApiException"><code class="xref py py-class docutils literal"><span class="pre">ApiException</span></code></a> class
and they are</p>
<dl class="docutils">
<dt><a class="reference internal" href="clx.xms.html#clx.xms.exceptions.ErrorResponseException" title="clx.xms.exceptions.ErrorResponseException"><code class="xref py py-class docutils literal"><span class="pre">ErrorResponseException</span></code></a></dt>
<dd>If the XMS server responded with a JSON error object containing an
error code and error description. See the <a class="reference external" href="https://www.clxcommunications.com/docs/sms/http-rest.html#http-errors">HTTP Errors</a> section in
the XMS documentation.</dd>
<dt><a class="reference internal" href="clx.xms.html#clx.xms.exceptions.NotFoundException" title="clx.xms.exceptions.NotFoundException"><code class="xref py py-class docutils literal"><span class="pre">NotFoundException</span></code></a></dt>
<dd>If the XMS server response indicated that the desired resource
does not exist. In other words, if the server responded with
HTTP status 404 Not Found. During a fetch batch or group
operation this exception would typically indicate that the batch
or group identifier is incorrect.</dd>
<dt><a class="reference internal" href="clx.xms.html#clx.xms.exceptions.UnauthorizedException" title="clx.xms.exceptions.UnauthorizedException"><code class="xref py py-class docutils literal"><span class="pre">UnauthorizedException</span></code></a></dt>
<dd>Thrown if the XMS server determined that the authentication
token was invalid for the service plan.</dd>
<dt><a class="reference internal" href="clx.xms.html#clx.xms.exceptions.UnexpectedResponseException" title="clx.xms.exceptions.UnexpectedResponseException"><code class="xref py py-class docutils literal"><span class="pre">UnexpectedResponseException</span></code></a></dt>
<dd>If the XMS server responded in a way that the SDK did not expect and
cannot handle, the complete HTTP response body can be retrieved from
the exception object using the
<a class="reference internal" href="clx.xms.html#clx.xms.exceptions.UnexpectedResponseException.http_body" title="clx.xms.exceptions.UnexpectedResponseException.http_body"><code class="xref py py-attr docutils literal"><span class="pre">http_body</span></code></a>
attribute.</dd>
</dl>
<p>Note, internally this SDK uses the <a class="reference external" href="http://docs.python-requests.org/en/master/">Requests</a> library and when
performing XMS operations one may therefore encounter exceptions
raised by Requests. See the <a class="reference external" href="http://docs.python-requests.org/en/master/user/quickstart/#errors-and-exceptions">Requests errors and exceptions</a>
documentation for more.</p>
<p>Due to the use of exceptions, a typical XMS operation in the Python
SDK is surrounded by a try-catch statement such as:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>try:
    # Invoke synchronous XMS client call here.
except (requests.exceptions.RequestException, clx.xms.exceptions.ApiException) as ex:
    print(&#39;Failed to communicate with XMS: %s&#39; % str(ex))
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">SMS REST API tutorial</a><ul>
<li><a class="reference internal" href="#http-rest-messaging-api-basics">HTTP REST Messaging API basics</a></li>
<li><a class="reference internal" href="#interacting-with-xms-through-python">Interacting with XMS through Python</a></li>
<li><a class="reference internal" href="#connection-management">Connection management</a></li>
<li><a class="reference internal" href="#sending-batches">Sending batches</a></li>
<li><a class="reference internal" href="#fetching-batches">Fetching batches</a></li>
<li><a class="reference internal" href="#listing-batches">Listing batches</a></li>
<li><a class="reference internal" href="#other-xms-requests">Other XMS requests</a></li>
<li><a class="reference internal" href="#handling-errors">Handling errors</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Welcome to REST API SDK for SMS&#8217;s documentation!</a></li>
      <li>Next: <a href="modules.html" title="next chapter">clx</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/tutorial.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, CLX Communication.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
      |
      <a href="_sources/tutorial.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>